# 战场分析基站配送 Mod：需求梳理与信息收集清单

## 〇、已从 GameCodeReference 反编译获得的信息（2026-01-28 更新）

### GameMain 与当前星球
- **静态成员**：`GameMain.data`（类型 GameData），不是别的名字。
- **赋值时机**：在 `GameMain.Start()` 中，若 `GameMain.data == null` 则 `GameMain.data = new GameData()`，随后 NewGame/LoadCurrentGame；即**进入存档/新游戏并加载场景后**才有 data。
- **路径**：`GameMain.data.localPlanet` → PlanetData；`localPlanet.factory` → PlanetFactory；`factory.transport` → PlanetTransport。完整：`GameMain.data.localPlanet.factory.transport`。
- **注意**：Mod 用 `Type.GetType("GameMain, Assembly-CSharp")` 可能因程序集名或加载顺序失败，建议改为从已引用的游戏类型所在程序集取：`typeof(StationComponent).Assembly.GetType("GameMain")`。

### RefreshStationTraffic 调用方
- PlanetTransport.Import 末尾（约 261 行）：读档后调用 `RefreshStationTraffic(0)`。
- 约 480、1174 行：站点设置变更时调用。即游戏在「加载星球运输」和「改站设置」时会刷新本地配送。

### DefenseSystem / BattleBase 存储（参考 BattleBaseComponent.cs）
- **池子名**：`DefenseSystem.battleBases`（**不是** battleBasePool），类型 `ObjectPool<BattleBaseComponent>`，访问用 `.buffer[id]`、`.cursor`。
- **战利品真实位置**：在 **BattleBaseComponent.storage**（StorageComponent），即 `factory.factoryStorage.storagePool[battleBaseComponent.storageId]`。Init 中赋值 `this.storage = factory.factoryStorage.storagePool[this.storageId]`；AutoPickTrash 将拾取写入 `this.storage`；PlanetFactory.InsertIntoStorage 对战利品调用 `storageComponent.AddItemFilteredBanOnly` 写入同一 StorageComponent。
- **读取方式**：`battleBase.storage.grids`（StorageComponent.GRID[]），每格有 `itemId`、`count`。`.fighters` 为攻击无人机等，不是战利品。

### Mod 已按反编译结果修改（2026-01-28）
- **Plugin.RefreshLocalPlanetStationTraffic**：改为用 `typeof(StationComponent).Assembly.GetType("GameMain")` 解析 GameMain，避免 `"GameMain, Assembly-CSharp"` 在 BepInEx 下解析失败导致 data 一直为 null。
- **BattlefieldBaseHelper.GetFactoryForPlanet**：同上，从游戏程序集解析 GameMain。
- **BattlefieldBaseHelper.SyncBattleBaseStorageToStation**：① 使用 `defenseSystem.battleBases` 和 `.buffer`；② 从 **battleBase.storage**（StorageComponent）的 **.grids**（GRID[]，itemId/count）读取并写入 station.storage，先清空再按格填充。

### 下一步需收集（可选）
- **StorageComponent**：若以后要兼容“从 storage 读”的逻辑，可反编译 StorageComponent 确认 `.grids` 等字段结构；当前同步已改为从 **combatModule.moduleFleets[0].fighters** 读取，可暂不反编译。

---

## 一、需求目标（我们要达到什么）

- **功能**：让**配送无人机 / 机甲**能从**战场分析基站**里直接取物品（本地配送）。
- **表现**：同星球上，战场分析基站里有战利品时，**物流配送器**（储物箱上的）或**机甲物流栏**设为「需求」该物品后，无人机会从基站取货并送到配送器/机甲。
- **不改变**：原版仍可用传送带从基站运出、或基站上放箱子+配送器（该配送器只能配送单一物品）；本 Mod 是**额外**让基站本身作为本地供应源。

---

## 二、实现思路（当前 Mod 已做 / 待验证）

| 环节 | 做法 | 状态 |
|------|------|------|
| 基站进站池 | PlanetFactory.CreateEntityLogicComponents 补丁：`desc.isBattleBase` 时也调用 `NewStationComponent` | ✅ 日志有「已为战场分析基站创建 StationComponent」 |
| 点击打开基站 UI | StationComponent.Init 补丁：entity 为战场分析基站时不清写 stationId，避免被当成物流站打开 | ✅ 你反馈 UI 可打开 |
| 匹配时考虑基站 | RematchLocalPairs 补丁：遍历 1..stationCursor 时把战场分析基站当供应源，且 id=1 的基站也会被考虑 | ✅ 已写，需 RematchLocalPairs 被调用 |
| 基站库存来源 | BattleBase 组件存储 → 同步到 StationComponent.storage（SyncBattleBaseStorageToStation） | ⚠ 依赖反射，需确认 BattleBase 存储字段名 |
| 触发匹配 | 每 10 秒对「当前星球」调用 `RefreshStationTraffic(0)` | ❌ 日志显示 `data=null`，拿不到 GameMain.data |

**当前卡点**：在 `Update()` 里用 `GameMain.data` 取当前星球并调用 `RefreshStationTraffic` 时，**data 为 null**，导致从未成功触发本地配送匹配。需要先弄清 GameMain 的访问方式与调用时机。

---

## 三、必须先收集的信息

### 1. GameMain 与「当前星球 / 工厂」的访问方式（优先）

- **目的**：在 Mod 里正确拿到「当前玩家所在星球的 PlanetTransport」，才能调用 `RefreshStationTraffic(0)` 或等价逻辑。
- **需要确认**：
  - `GameMain` 类里，保存游戏数据的是哪个静态成员？是 `data` 还是别的名字（如 `instance`、`gameData`）？
  - 该成员的类型是什么？何时被赋值（主菜单、读档后、进入星球后）？
  - 从该对象如何走到「当前星球」？是 `data.localPlanet` 还是例如 `data.mainPlayer.planet`？
  - 当前星球的「工厂」在哪？是 `localPlanet.factory` 还是别的路径？工厂里的 `transport` 是否就是 `PlanetTransport`？
- **建议做法**：
  - **反编译**：在 dnSpy 里打开 `Assembly-CSharp.dll`，搜索类 `GameMain`，查看其静态属性/字段（如 `data`、`instance`、`gameData` 等），以及类型定义里如何引用「当前星球」「工厂」「transport」。
  - **或日志**：在 Mod 里用反射枚举 `GameMain` 的静态属性和字段名，在**进存档并站在星球上后**打一次日志，看哪些非 null，便于确定正确路径。

### 2. 何时可以安全调用 RefreshStationTraffic

- **目的**：避免在菜单/加载阶段调用，导致 data 为 null 或未就绪。
- **需要确认**：
  - 游戏在什么时机会调用 `PlanetTransport.RefreshStationTraffic`？（例如：建造/升级建筑、改物流设置、进入星球、定时刷新等。）
  - 若我们在「进入星球且工厂已加载」后再调用，应用哪个入口更合适？（例如 `GameMain.data.localPlanet.factory` 已非 null 时再调。）
- **建议做法**：
  - 在 dnSpy 里搜索 `RefreshStationTraffic` 的调用处，看调用方是谁、在什么条件下调用。
  - Mod 里可在 `Update()` 中加条件：仅当 `data != null && localPlanet != null && factory != null` 时才调用 `RefreshStationTraffic`，并打一次「已主动调用」日志确认。

### 3. BattleBase 组件的存储结构（用于同步到 Station）

- **目的**：`SyncBattleBaseStorageToStation` 要从战场的「真实库存」读到 Station 的 storage，才能被匹配和取货。
- **需要确认**：
  - `DefenseSystem` 里存放战场基站组件的池子叫什么？是 `battleBasePool` 还是别的？
  - 单个战场基站组件（如 BattleBaseComponent）里，物品存储的字段/属性名是什么？类型是什么？（例如 `storage`、`items`、`inventory`，以及元素是否包含 itemId、count。）
- **建议做法**：
  - **反编译**：在 dnSpy 里搜索 `DefenseSystem`、`BattleBase`、`ClearItems_BattleBase`、`TakeBackItems_BattleBase`，找到组件类型和存储字段。
  - **或日志**：在 Mod 里用反射枚举 BattleBase 组件的属性和字段，在已知有战利品的基站上打一次，看哪个字段是数组/列表且元素有 itemId、count。

### 4. 战场分析基站的 protoId（可选但建议确认）

- **目的**：确保 Mod 用正确的建筑 ID 识别「战场分析基站」。
- **需要确认**：当前配置 2318 是否与你的游戏版本一致。
- **建议做法**：
  - dnSpy 里查 LDB / 建筑表 / PrefabDesc 中与「战场分析基站」相关的 protoId；
  - 或运行时用 UnityExplorer 选中基站实体，看 `entity.protoId`；
  - 或在 Mod 的 `IsBattlefieldAnalysisBase` 里对 `entity.protoId` 打一次日志（DebugLog 开启）。

---

## 四、建议的反编译与日志清单（按优先级）

| 优先级 | 内容 | 做法 | 得到什么 |
|--------|------|------|----------|
| 1 | GameMain 的静态成员与数据类型 | dnSpy 打开 GameMain，列出静态属性/字段及类型 | 正确的「data / gameData / instance」名和类型，以及如何走到 localPlanet、factory、transport |
| 2 | GameMain.data 的赋值时机 | 搜索对 GameMain.data（或你查到的名字）的赋值 | 知道何时 data 非 null，Mod 应在何时取 data |
| 3 | RefreshStationTraffic 的调用方 | dnSpy 搜索 RefreshStationTraffic 的引用 | 知道游戏何时刷新本地配送，是否可复用或仿照调用时机 |
| 4 | DefenseSystem / BattleBase 的存储 | dnSpy 搜索 DefenseSystem、BattleBase、ClearItems_BattleBase | BattleBase 的池子名、组件类型、存储字段名与结构 |
| 5 | 运行时 data 是否为 null 的时机 | Mod 里在 Update 打日志：当前帧 GameMain.data / localPlanet / factory 是否 null | 确认在星球上时是否已非 null，以及是否需延迟几秒再调 RefreshStationTraffic |

---

## 五、拿到上述信息后 Mod 的修改方向

1. **取当前星球 transport**：用正确的 GameMain 成员名和路径（如 `GameMain.xxx.localPlanet.factory.transport`）替换当前反射逻辑；仅在 `data != null && localPlanet != null && factory != null` 时调用 `RefreshStationTraffic(0)`。
2. **BattleBase 同步**：根据反编译得到的存储字段名，修正 `SyncBattleBaseStorageToStation` 的反射（若字段名不是 `storage`，则改为实际名）。
3. **（可选）** 若确认游戏会在某些时机自动调用 `RefreshStationTraffic`，可考虑依赖该时机而非每 10 秒主动调，减少对 GameMain 的依赖。

---

## 六、当前日志中已反映的问题

- **「RefreshStationTraffic 未调用: data=null」**：在 `Update()` 执行时，用 `GameMain.data` 取到的值为 null。可能原因：
  - 游戏里实际不是 `GameMain.data` 而是别的静态成员；
  - 或调用时机太早（仍在主菜单/加载界面），data 尚未赋值。

因此**最优先**是完成上表第 1、2、5 项，确定 GameMain 的正确访问方式与可调用时机。
