=== 从 StationComponent.cs 导出中提取的关键信息 ===

1. 配送逻辑
   - 游戏没有 FindItemSource / CanPickupItem。
   - 本地配送通过 RematchLocalPairs(StationComponent[] stationPool, ...) 匹配供需。
   - 是否“有本地供应”由 HasLocalSupply(int itemId, int countAtLeast) 判断，返回 storage 下标 (0~5) 或 -1。

2. StationComponent 相关
   - 物品存储：storage (StationStore[])，每格有 itemId, count, localLogic (Supply/Demand)。
   - 建筑身份：StationComponent 自身没有 protoId；需用 factory.entityPool[entityId].protoId 判断建筑类型。
   - 字段：id, entityId, planetId, storage, 等。

3. 补丁实现
   - 对 HasLocalSupply 做 Postfix：当原逻辑返回 -1 时，若当前站是“战场分析基站”（按 entityPool[entityId].protoId 判断），则遍历 storage，若有 itemId 且 count >= countAtLeast 的格子，返回该下标。

4. 战场分析基站建筑 ID (protoId)
   - 当前默认填 2318（仅为占位，需在游戏中确认）。
   - 正确 ID 获取方式：dnSpy 打开 Assembly-CSharp，查 LDB / PrefabDesc / 建筑表，或运行时用 UnityExplorer 看 entity 的 protoId。
   - 可在 BepInEx 配置中修改：BepInEx/config/com.yourname.battlefieldanalysisbasedeliver.cfg 里 BattlefieldAnalysisBaseProtoId。

5. 获取当前星球工厂 (GetFactoryForPlanet)
   - 尝试 GameMain.data.localPlanet.factory（若 planetId 一致）。
   - 备选 GameMain.data.factories[planetId] 或 .get_Item(planetId)。

=== 从 CargoTraffic.cs 反编译得出的结论 ===

1. CargoTraffic 不负责 stationPool
   - CargoTraffic 管理的是：传送带(belt)、路径(path)、分拣器(splitter)、监控器(monitor)、喷涂器(spraycoater)、堆叠器(piler) 等。
   - 文件中没有 stationPool、stationCursor、RematchLocalPairs、InternalTickLocal 等关键词。
   - 本地配送的「站点池」和 RematchLocalPairs 的调用不在 CargoTraffic 里。

2. stationPool 的来源（据 StationComponent.cs）
   - RematchRemotePairs 里：StationComponent[] stationPool = galacticTransport.stationPool（远程用）。
   - InternalTickLocal / RematchLocalPairs 的 stationPool 由「调用方」传入，调用方很可能是 PlanetTransport 或同一层逻辑（需反编译 PlanetTransport / 调用 InternalTickLocal 的类才能确认谁构建并传入本地 stationPool）。

3. CargoTraffic 里唯一与「站点」相关的代码
   - 约 3812、3818 行：prefabDesc.isStation（以及 gammaRayReceiver、isPowerExchanger）用于判断传送带连接的是否为「站点类」建筑，从而决定 entitySignPool 位置用的系数（1.2f vs 0.5f）。
   - 说明「是否为站点」由 PrefabDesc 的 isStation 等标记决定；战场分析基站若在表里没有 isStation，就不会被当作物流站点，很可能也不会被加入 stationPool。

4. 下一步若要「把战场分析基站加入本地配送」
   - 需要在 dnSpy 里找到：谁创建/填充「本地」的 stationPool（例如 PlanetTransport 或 PlanetFactory 里与 station 相关的 pool/cursor），以及何时对每个 StationComponent 调用 RematchLocalPairs。
   - 要么补丁「构建 stationPool 的地方」把基站对应的 StationComponent（若基站有的话）纳入；要么补丁「为建筑分配 StationComponent / stationId」的逻辑，让战场分析基站也获得 StationComponent 并进入 pool。建议反编译并导出 PlanetTransport、PlanetFactory（搜索 stationPool、stationCursor、RematchLocalPairs、InternalTickLocal）再继续。

=== 从 PlanetTransport.cs 反编译得出的结论 ===

1. 本地 stationPool 在 PlanetTransport 里
   - PlanetTransport.stationPool (StationComponent[])、stationCursor、stationRecycle。
   - 站点通过 NewStationComponent(int _entityId, int _pcId, PrefabDesc _desc) 加入 pool（约 279 行）。

2. 谁会被加入 pool
   - 只有「有人调用了 NewStationComponent(_entityId, _pcId, _desc)」的建筑才会进 stationPool。
   - 调用方不在 PlanetTransport 里，多半在 PlanetFactory（建造/加载时根据 PrefabDesc 决定是否调用 NewStationComponent）。若战场分析基站的 PrefabDesc 没有“站点”相关标记，就永远不会调用 NewStationComponent，基站就不会进 pool。

3. 本地配送匹配流程（约 1183–1199 行）
   - RefreshStationTraffic(keyStationId)：先对 pool 里每个站 ClearLocalPairs()，再对每个站调用 RematchLocalPairs(this.stationPool, this.stationCursor, keyStationId, logisticDroneCarries)。
   - 所以 RematchLocalPairs 只对「已在 stationPool 里的站」执行；若基站不在 pool 里，永远不会对基站执行 RematchLocalPairs，我们的 RematchLocalPairs_Patch 里“把基站当供应”的逻辑也触达不到基站本身。

4. InternalTickLocal 的调用（约 889–895 行）
   - GameTick 里 for (i=1; i<stationCursor; i++) 对每个 stationPool[i] 调用 InternalTickLocal(..., this.stationPool)。同样只有已在 pool 里的站才会被 tick。

5. 结论与可行补丁方向
   - 要让战场分析基站参与本地配送，必须让基站「进入 stationPool」或「在匹配时被当作供应源」。
   - 方向 A：在「调用 NewStationComponent 的地方」（dnSpy 里在 PlanetFactory 搜 NewStationComponent）做 Prefix/Postfix，当建筑为战场分析基站（entity.protoId == BattlefieldAnalysisBaseProtoId）时，也对该 entity 调用 planetTransport.NewStationComponent(entityId, pcId, prefabDesc)。prefabDesc 可从 LDB.models.Select(factory.entityPool[entityId].modelIndex).prefabDesc 取；若该 prefab 没有 stationMaxItemKinds/stationDronePos 等，需再查表或做最小化 PrefabDesc。
   - 方向 B：不把基站加入 pool，而在 RefreshStationTraffic 的 Postfix 里，自己遍历 factory.entityPool，找出 protoId == 战场分析基站的 entity，再为每个「需求站」尝试与这些 entity 的库存做匹配并写入配对；这要求基站的物品存储能被访问（若基站没有 StationComponent，可能要用别的组件/字段取库存），实现难度较大。
   - 建议先做方向 A：在 dnSpy 里找到 PlanetFactory 中调用 NewStationComponent 的代码，确认调用条件（是否看 PrefabDesc.isStation 等），再为该处加 Harmony 补丁，使战场分析基站在建造/加载时也调用 NewStationComponent。

=== 战场分析基站 UI 无法打开 ===

原因：为参与配送，Mod 为基站也创建了 StationComponent，entity 同时有 stationId 和 battleBaseId。游戏点击建筑时若先根据 stationId 打开物流站 UI，就不会再打开战场分析基站 UI。

修复思路：在 dnSpy 中搜索“打开建筑 UI”的逻辑（stationId、battleBaseId、PlayerController、UIBuilding 等），找到“根据 entity 决定打开哪个窗口”的代码，改为当 battleBaseId > 0 时优先打开战场分析基站 UI。详见 GameCodeReference/战场分析基站UI修复说明.md。
