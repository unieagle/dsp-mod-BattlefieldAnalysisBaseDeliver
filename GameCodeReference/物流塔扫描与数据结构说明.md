# 游戏如何扫描星球上的物流塔（反编译代码分析）

根据 GameCodeReference 中的反编译代码，本文说明：  
（1）游戏如何扫描星球上所有物流塔、查看配置物品、库存及本地/星际供需；  
（2）**游戏如何将物品放入星际物流塔**（飞船返航卸货、行星无人机送货、传送带入塔）。  

已依据反编译文件：`PlanetTransport.cs`、`StationComponent.cs`、`StationStore.cs`、`PlanetFactory.cs`、`PrefabDesc.cs`、`UIControlPanelWindow.cs`、`ELogisticStorage.cs`、`EntityData.cs`、`GalacticTransport.cs` 确认，不猜测。

---

## 1. 数据从哪里来

- **星球工厂**：每个星球有一个 `PlanetFactory`（`planet.factory` 或 `gameData.galaxy.astrosFactory[planet.astroId]`）。
- **星球运输**：每个 `PlanetFactory` 持有一个 `PlanetTransport` 实例：`factory.transport`。
- **物流塔池**：所有物流塔（本地、星际、轨道采集器、矿脉采集器）都保存在：
  - `PlanetTransport.stationPool`：`StationComponent[]`
  - `PlanetTransport.stationCursor`：int，表示“下一个空闲槽位”的索引，有效塔的 id 范围是 `[1, stationCursor - 1]`。

因此：**扫描某星球上所有物流塔 = 遍历该星球 `factory.transport` 的 `stationPool`**。

---

## 2. 如何遍历星球上的所有物流塔

游戏内实际使用的遍历方式（与 `PlanetTransport.GameTick`、`RefreshStationTraffic`、`UIControlPanelWindow.DetermineFilterResults` 等一致）：

```csharp
PlanetFactory factory = planet.factory;  // 或 gameData.galaxy.astrosFactory[planet.astroId]
PlanetTransport transport = factory.transport;
StationComponent[] stationPool = transport.stationPool;
int stationCursor = transport.stationCursor;

for (int i = 1; i < stationCursor; i++)
{
    StationComponent station = stationPool[i];
    if (station != null && station.id == i)  // 有效塔：非空且 id 与下标一致
    {
        // 此处得到该星球上的一个物流塔 station
        // station.entityId 对应 factory.entityPool 中的实体
        // station.isStellar 可区分 星际 / 本地
    }
}
```

要点：

- 下标从 **1** 开始，0 不用。
- 有效条件：`stationPool[i] != null && station.id == i`（回收过的槽位可能 id 被清空，所以必须校验）。

---

## 3. 如何区分“星际物流塔”和“本地物流塔”

在 `StationComponent` 上：

- **`station.isStellar`**  
  - `true`：星际相关（星际物流塔 或 轨道采集器）。  
  - `false`：本地相关（本地物流塔 或 矿脉采集器）。

更细的类型（与 UI 控制面板一致）可这样判：

- `isStellar && !isCollector` → 星际物流塔（InterstellarStation）
- `isStellar && isCollector` → 轨道采集器（OrbitCollector）
- `!isStellar && isVeinCollector` → 矿脉采集器（VeinCollector）
- `!isStellar && !isVeinCollector` → 本地物流塔（LocalStation）

来源：`StationComponent.Init` 里 `this.isStellar = _desc.isStellarStation`，而 `PrefabDesc.isStellarStation` 来自建筑预制体配置。

---

## 4. 配置物品、库存与本地/星际供需

每个物流塔是一个 `StationComponent`，其 **槽位数组** 为：

- **`station.storage`**：`StationStore[]`  
  长度由预制体决定（`PrefabDesc.stationMaxItemKinds`），例如星际塔常为 3 或 4 个槽位。

每个 **`StationStore`** 表示一个“物品槽位”，包含：

| 字段 | 含义 |
|------|------|
| `itemId` | 该槽位配置的物品 ID（0 表示未配置） |
| `count` | 当前库存数量 |
| `inc` | 数量的小数/增量部分（统计用） |
| `max` | 该槽位最大容量（配置的“数量上限”） |
| `localLogic` | 本地供需模式：`ELogisticStorage.None` / `Supply` / `Demand` |
| `remoteLogic` | 星际供需模式：同上（仅星际塔有效；本地塔应为 None） |
| `localOrder` | 本地物流已下单数量（无人机在途） |
| `remoteOrder` | 星际物流已下单数量（星际船在途） |

因此：

- **配置的物品**：遍历 `station.storage`，看每个 `store.itemId`（非 0 即已配置）。
- **库存**：同一槽位的 `store.count`、`store.inc`、`store.max`。
- **本地供需**：`store.localLogic`（Supply/Demand/None）。
- **星际供需**：`store.remoteLogic`（仅当 `station.isStellar == true` 时才有意义；本地塔的 remote 会在逻辑里被置为 None）。

`StationStore` 还提供了一些派生属性（在反编译代码中有）：  
`localSupplyCount`、`localDemandCount`、`remoteSupplyCount`、`remoteDemandCount` 等，都是基于 `count`、`localOrder`、`remoteOrder`、`max` 计算得出的。

---

## 5. 实体与物流塔的对应关系

- 每个建筑实体在 `factory.entityPool` 中有一条 `EntityData`。
- `EntityData.stationId`：若该实体是物流塔，则为其在 `transport.stationPool` 中的 id（即上面的下标 `i`）；非物流塔为 0。

因此：

- 由实体找塔：`int stationId = factory.entityPool[entityId].stationId`，再 `transport.stationPool[stationId]`。
- 由塔找实体：`station.entityId`，再 `factory.entityPool[station.entityId]`。

控制面板、传送带连接等逻辑都是通过 `entityPool[entityId].stationId` 再访问 `transport.stationPool[stationId]` 来拿到 `StationComponent` 的。

---

## 6. 游戏内实际“扫描”的典型用法

1. **每帧/每 tick 更新**（`PlanetTransport.GameTick`）  
   遍历 `for (int i = 1; i < stationCursor; i++)`，对每个有效 `stationPool[i]` 做本地/星际逻辑、收集器等更新。

2. **刷新本地物流配对**（`PlanetTransport.RefreshStationTraffic`）  
   同样遍历所有有效塔，先 `ClearLocalPairs`，再对每个塔 `RematchLocalPairs(stationPool, stationCursor, ...)`，用于本地无人机供需匹配。

3. **控制面板筛选列表**（`UIControlPanelWindow.DetermineFilterResults`）  
   对每个星球的 `planetFactory.transport.stationPool` 从 1 到 `stationCursor-1` 遍历，根据 `station.id == k` 判断有效，再根据 `isStellar`、`isCollector`、`isVeinCollector` 得到类型，用 `station.storage[l].itemId`、`localLogic`、`remoteLogic` 做物品和供需筛选。

4. **设置/读取槽位**（`PlanetTransport.SetStationStorage`）  
   通过 `GetStationComponent(stationId)` 拿到 `StationComponent`，再对其 `storage[storageIdx]` 的 `itemId`、`max`、`localLogic`、`remoteLogic` 进行读写；若 `!isStellar` 会强制把 `remoteLogic` 设为 None。

---

## 7. 小结（Mod 中如何“扫描”星际塔的配置与供需）

- **入口**：`planet.factory.transport` → `stationPool`、`stationCursor`。
- **遍历**：`for (int i = 1; i < transport.stationCursor; i++)`，且 `stationPool[i] != null && stationPool[i].id == i`。
- **只关心星际物流塔**：在上述循环中加 `if (!station.isStellar || station.isCollector) continue;`。
- **每个塔的配置与供需**：遍历 `station.storage[]`，读 `itemId`、`count`、`max`、`localLogic`、`remoteLogic`（星际塔才看 `remoteLogic`）。

---

## 8. 补充：ELogisticStorage、EntityData、GalacticTransport（反编译确认）

- **ELogisticStorage**（`ELogisticStorage.cs`）：  
  `None = 0`，`Supply = 1`，`Demand = 2`。

- **EntityData**（`EntityData.cs`）：  
  实体结构体中有 `stationId`（int）。若该实体是物流塔，则为其在 `PlanetTransport.stationPool` 中的 id；非物流塔为 0。另有 `dispenserId` 等其它组件 id。

- **GalacticTransport**（`GalacticTransport.cs`）：  
  - 全局星际塔池：`stationPool`（`StationComponent[]`），下标为星际塔的 `gid`（与星球内 `station.id` 不同）。  
  - `AddStationComponent(planetId, station)`：将星际塔注册到全局池，并设置 `station.planetId`。  
  - `RemoveStationComponent(gid)`：从池中移除并回收 gid。  
  - 星际船的配对与航线在 `StationComponent.InternalTickRemote` 中通过 `gStationPool`（即 `gameData.galacticTransport.stationPool`）访问其它星球的塔。

---

## 9. 游戏如何将物品放入星际物流塔（飞船返航、无人机送货、传送带）

以下均依据反编译代码中的**具体调用链与方法实现**，不猜测。

### 9.1 唯一“写入库存”的两种接口

游戏把物品**放进物流塔槽位**的入口只有两类：

1. **`StationComponent.AddItem(int itemId, int count, int inc)`**（`StationComponent.cs` 约 4608–4680 行）  
   - 在 `storage` 上 lock 后，**只**在已配置了该物品的槽位上加数量：按索引 0、1、2、3、4、5 依次检查 `storage[i].itemId == itemId`，找到则 `storage[i].count += count`、`storage[i].inc += inc` 并返回；若没有任何槽位配置了该 `itemId`，则返回 0，不写入。  
   - 即：**只有槽位预先配置了该物品（itemId）时，才会增加库存**；未配置的槽位不会通过 AddItem 写入。

2. **`StationComponent.InputItem(int itemId, int needIdx, int stack, int inc)`**（`StationComponent.cs` 约 4683–4705 行）  
   - 传送带入塔专用。若 `needIdx < storage.Length` 且 `storage[needIdx].itemId == itemId`，则在该槽位上加 `stack` 和 `inc`；若 `itemId == 1210`（空间翘曲器），则增加 `warperCount`，不写 `storage`。  
   - 即：**传送带只能往已配置的槽位或 1210 的 warper 计数里加**。

因此：**无论是飞船、无人机还是传送带，放入星际塔（或任意塔）的物品，都只会进入“已配置该物品”的槽位**。

### 9.2 星际飞船取货返回 / 送货到目标塔时放入塔

逻辑在 **`StationComponent.InternalTickRemote`**（`StationComponent.cs`）中，由 `PlanetTransport.GameTick` 对每个 `isStellar` 的塔调用。

- **飞船送货到“目标星际塔”**（飞船带着货飞到目标塔并卸货）：  
  - 当 `ptr2.direction > 0` 且 `ptr2.t < 0` 时，表示飞船到达目标塔。  
  - 目标塔：`stationComponent = gStationPool[ptr2.otherGId]`（`gStationPool` 即 `gameData.galacticTransport.stationPool`）。  
  - 若 `ptr2.itemCount > 0`，则调用 **`stationComponent.AddItem(ptr2.itemId, ptr2.itemCount, ptr2.inc)`**（约 2704–2705 行），把飞船上的货物写入目标塔；随后统计、`NotifyShipDelivery`、清零飞船的 `itemCount/inc`、更新目标塔的 `remoteOrder`。  
  - 即：**飞船送货到目标星际塔 = 对目标塔的 StationComponent 调用 AddItem**。

- **飞船取货后返回“出发塔”并卸货**（从其它星球拉货回到本塔）：  
  - 当 `ptr2.direction < 0` 且 `ptr2.t < 0` 时，表示飞船回到出发塔（`this`）。  
  - 调用 **`this.AddItem(ptr2.itemId, ptr2.itemCount, ptr2.inc)`**（约 2113–2114 行），把飞船上的货物写入本塔；随后统计、`NotifyShipDelivery`、清理订单、飞船回 idle。  
  - 即：**飞船取货返回 = 对“本塔”StationComponent 调用 AddItem**。

两处都只通过 **AddItem** 写入，因此同样遵守“只写入已配置该 itemId 的槽位”的规则。

### 9.3 行星物流无人机送货到塔（含星际塔）时放入塔

逻辑在 **`StationComponent.InternalTickLocal`**（`StationComponent.cs`）中，由 `PlanetTransport.GameTick` 对每个塔调用；`stationPool` 为本星球的塔池（含本地塔与星际塔）。

- **无人机到达目标塔并卸货**：  
  - 当 `workDroneDatas[j].t >= workDroneDatas[j].maxt + 1.5f` 时，表示无人机飞到目标塔并进入“已到达”状态。目标塔：`stationComponent3 = stationPool[workDroneDatas[j].endId]`。  
  - 若 `workDroneDatas[j].itemCount > 0`，则调用 **`stationComponent3.AddItem(workDroneDatas[j].itemId, workDroneDatas[j].itemCount, workDroneDatas[j].inc)`**（约 1860–1861 行），把无人机携带的货物写入**目标塔**；随后统计、`NotifyDroneDelivery`、更新目标塔的 `localOrder`、清零无人机的 `itemCount/inc`。  
  - 即：**行星无人机送货到任意塔（包括星际物流塔）= 对目标塔的 StationComponent 调用 AddItem**。目标塔可以是本星球上任意 `stationPool` 中的塔，不区分本地/星际。

- **无人机从目标塔取货后返回“本塔”并卸货**：  
  - 当 `workDroneDatas[j].t < -1.5f` 时，表示无人机回到“本塔”（`this`）。  
  - 调用 **`this.AddItem(workDroneDatas[j].itemId, workDroneDatas[j].itemCount, workDroneDatas[j].inc)`**（约 1991–1992 行），把无人机携带的货物写入本塔；随后统计、`NotifyDroneDelivery`、清理订单、无人机回 idle。  
  - 即：**无人机取货返回本塔 = 对“本塔”StationComponent 调用 AddItem**。

同样只通过 **AddItem** 写入，故同样只进入已配置该物品的槽位。

### 9.4 传送带将物品放入塔（含星际塔）

- **调用链**：`PlanetTransport.GameTick_InputFromBelt`（`PlanetTransport.cs` 约 631–641 行）→ 对每个有效 `stationPool[i]` 调用 **`station.UpdateInputSlots(cargoTraffic, entitySignPool, active)`**。  
- **UpdateInputSlots**（`StationComponent.cs` 约 366–426 行）：从传送带（`CargoPath`）**TryPickItemAtRear** 取出物品，得到 `itemId`、`stack`、`inc` 和槽位索引 `needIdx`（来自 `this.needs` 匹配），然后调用 **`this.InputItem(itemId, needIdx, stack, inc)`**。  
- **InputItem** 行为见上文：只往 `storage[needIdx].itemId == itemId` 的槽位加，或 `itemId == 1210` 时加 `warperCount`。  
- 即：**传送带入塔 = UpdateInputSlots → InputItem**，只写入已配置的槽位（或 1210 的 warper）。

### 9.5 小结：物品如何进入星际物流塔

| 来源           | 调用链 / 位置                                      | 写入方式 |
|----------------|----------------------------------------------------|----------|
| 星际飞船送货   | `InternalTickRemote`，到达目标塔时 `ptr2.direction > 0` 且 `ptr2.t < 0` | 目标塔 `AddItem(ptr2.itemId, ptr2.itemCount, ptr2.inc)` |
| 星际飞船返航   | `InternalTickRemote`，回到出发塔时 `ptr2.direction < 0` 且 `ptr2.t < 0` | 本塔 `this.AddItem(ptr2...)` |
| 行星无人机送货 | `InternalTickLocal`，到达目标塔时 `t >= maxt + 1.5f` 且 `itemCount > 0`  | 目标塔 `stationComponent3.AddItem(...)`（目标可为星际塔） |
| 行星无人机返航 | `InternalTickLocal`，回到本塔时 `t < -1.5f`        | 本塔 `this.AddItem(...)` |
| 传送带         | `GameTick_InputFromBelt` → `UpdateInputSlots` → `InputItem` | 仅已配置槽位或 1210 的 warperCount |

**统一规则**：所有入塔物品都只进入**已配置该物品 ID 的槽位**（或 1210 的 warper）；`AddItem` 若找不到匹配槽位则返回 0，不写入任何槽位。

---

以上第 8、9 节及 ELogisticStorage 细节依据 `ELogisticStorage.cs`、`EntityData.cs`、`GalacticTransport.cs`、`StationComponent.cs`（AddItem、InputItem、InternalTickLocal、InternalTickRemote）、`PlanetTransport.cs`（GameTick、GameTick_InputFromBelt）的反编译代码归纳，无猜测。
