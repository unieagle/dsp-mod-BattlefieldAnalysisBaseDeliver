# 战场分析基站配送支持 - 逻辑分析

## 当前实现架构（方案C：虚拟配送器）

### 1. 核心思路
为每个战场分析基站创建一个**虚拟的 DispenserComponent**，将其添加到 `PlanetTransport.dispenserPool` 中，使用**正数ID**。这样战场基站就能被游戏原生的物流系统识别为"供应站"。

---

## 执行流程

### 阶段1：游戏加载/初始化

#### 1.1 PlanetFactory.Init Postfix
```csharp
// 文件: PlanetFactory_Init_Patch.cs
// 触发时机: 新游戏或新星球初始化时
VirtualDispenserManager.CreateVirtualDispensers(factory);
```

**作用**：
- 遍历所有 `BattleBaseComponent`
- 为每个战场基站创建一个虚拟配送器
- 分配正数ID（从 `dispenserCursor` 获取并递增）
- 初始化虚拟配送器的所有字段（包括数组字段）
- 建立映射：`virtualDispenserId ↔ battleBaseId`

#### 1.2 PlanetFactory.Import Postfix
```csharp
// 文件: PlanetFactory_Import_Patch.cs
// 触发时机: 加载存档时
VirtualDispenserManager.Clear();  // 清空旧映射
VirtualDispenserManager.CreateVirtualDispensers(factory);  // 重新创建
```

**作用**：确保存档加载后虚拟配送器正确创建

#### 1.3 PlanetFactory.Free Prefix
```csharp
// 文件: PlanetFactory_Free_Patch.cs
// 触发时机: 切换星系、关闭游戏时
VirtualDispenserManager.Clear();  // 清理映射
```

**作用**：避免内存泄漏

---

### 阶段2：配对系统（RefreshDispenserTraffic）

#### 2.1 触发条件
游戏原生会在以下情况调用 `RefreshDispenserTraffic`：
- 配送器的 `filter`（过滤器）改变
- 配送器的模式（供应/需求）改变
- 其他物流设置改变

**我们的额外触发**：
- `BattleBaseComponent.AutoPickTrash` Postfix：当战场基站捡起新物品类型时

#### 2.2 RefreshDispenserTraffic Postfix
```csharp
// 文件: PlanetTransport_RefreshDispenserTraffic_NEW.cs
// 调用时机: RefreshDispenserTraffic 执行后

// 1. 确保虚拟配送器已创建（解决时序问题）
VirtualDispenserManager.CreateVirtualDispensers(factory);

// 2. 遍历所有战场基站
for (battleBaseId = 1; battleBaseId < battleBases.Length; battleBaseId++)
{
    // 3. 获取对应的虚拟配送器ID
    if (!VirtualDispenserManager.TryGetVirtualDispenserId(battleBaseId, out int virtualDispenserId))
        continue;
    
    // 4. 遍历基站的所有 grids（物品格子）
    for (gridIdx = 0; gridIdx < grids.Length; gridIdx++)
    {
        int itemId = grids[gridIdx].itemId;
        int count = grids[gridIdx].count;
        
        if (itemId <= 0 || count <= 0) continue;
        
        // 5. 查找需求方配送器（filter == itemId 且处于需求模式）
        for (demandId = 1; demandId < dispenserCursor; demandId++)
        {
            var demandDispenser = dispenserPool[demandId];
            
            if (demandDispenser.filter != itemId) continue;  // 过滤器不匹配
            if (demandDispenser.playerMode != EPlayerDeliveryMode.Demand) continue;  // 不是需求模式
            
            // 6. 检查是否已存在相同配对（幂等性）
            bool alreadyExists = false;
            for (int i = 0; i < demandDispenser.playerPairCount; i++)
            {
                if (demandDispenser.pairs[i].supplyId == virtualDispenserId &&
                    demandDispenser.pairs[i].supplyIndex == gridIdx)
                {
                    alreadyExists = true;
                    break;
                }
            }
            
            if (alreadyExists) continue;
            
            // 7. 添加配对：虚拟配送器[virtualDispenserId] → 需求配送器[demandId]
            AddPair(factory.transport, virtualDispenserId, gridIdx, demandId, 0);
            // supplyId = virtualDispenserId（正数！）
            // supplyIndex = gridIdx（基站的格子索引）
            // demandId = 需求方配送器ID
        }
    }
}
```

**结果**：
- 需求方配送器的 `pairs` 数组中添加了配对
- `pair.supplyId = virtualDispenserId`（正数）
- `pair.supplyIndex = gridIdx`

---

### 阶段3：派遣无人机（DispenserComponent.InternalTick）

#### 3.1 InternalTick Prefix
```csharp
// 文件: DispenserComponent_InternalTick_Patch.cs
// 调用时机: 每个配送器每帧执行一次

[HarmonyPrefix]
static void Prefix(DispenserComponent __instance, ...)
{
    // === 部分1：监控已派出的无人机（拦截到达虚拟配送器的无人机） ===
    for (int i = 0; i < __instance.workCourierCount; i++)
    {
        var courier = __instance.workCourierDatas[i];
        
        // 检查：无人机是否正在飞向虚拟配送器？
        if (courier.endId > 0 && VirtualDispenserManager.IsVirtualDispenser(courier.endId))
        {
            // 即将到达虚拟配送器（实际上是战场基站）
            if (courier.t >= courier.maxt - 0.2f && courier.itemCount == 0 && courier.direction > 0f)
            {
                // 获取对应的战场基站ID
                VirtualDispenserManager.TryGetBattleBaseId(courier.endId, out int battleBaseId);
                
                // 从基站取货
                if (TryPickFromBattleBase(factory, battleBaseId, gridIdx, courier.itemId, ...))
                {
                    // 设置返回状态
                    __instance.workCourierDatas[i].itemCount = actualCount;  // 装载物品
                    __instance.workCourierDatas[i].direction = -1f;          // 转向返回
                    __instance.workCourierDatas[i].t = courier.maxt;         // 开始返回
                }
            }
        }
    }
    
    // === 部分2：派出新的无人机（每60帧检查一次） ===
    _dispenserCounters[__instance.id]++;
    
    if (_dispenserCounters[__instance.id] >= DISPATCH_INTERVAL)  // 60帧
    {
        _dispenserCounters[__instance.id] = 0;
        
        // 检查是否有空闲无人机
        if (__instance.idleCourierCount > 0 && __instance.playerPairCount > 0)
        {
            // 检查是否有虚拟配送器的配对
            bool hasVirtualDispenserPair = false;
            for (int i = 0; i < __instance.playerPairCount; i++)  // ✅ 使用 playerPairCount
            {
                var pair = __instance.pairs[i];
                if (pair.supplyId > 0 && VirtualDispenserManager.IsVirtualDispenser(pair.supplyId))
                {
                    hasVirtualDispenserPair = true;
                    break;
                }
            }
            
            if (hasVirtualDispenserPair)
            {
                // 派出一个空载无人机
                DispatchOneCourierToBattleBase(__instance, factory, ...);
            }
        }
    }
}
```

#### 3.2 DispatchOneCourierToBattleBase
```csharp
// 遍历配对，找到虚拟配送器的配对
for (int i = 0; i < dispenser.playerPairCount; i++)
{
    var pair = dispenser.pairs[i];
    
    if (VirtualDispenserManager.IsVirtualDispenser(pair.supplyId))
    {
        int virtualDispenserId = pair.supplyId;
        int gridIdx = pair.supplyIndex;
        int battleBaseId = VirtualDispenserManager.GetBattleBaseId(virtualDispenserId);
        
        // 检查基站是否有货
        if (CheckBattleBaseHasItem(factory, battleBaseId, gridIdx, dispenser.filter))
        {
            // 派出空载无人机
            DispatchEmptyCourier(factory, dispenser, battleBaseId, gridIdx, ...);
            break;  // 只派出一个
        }
    }
}
```

#### 3.3 DispatchEmptyCourier
```csharp
// 获取战场基站的位置
var battleBase = battleBases[battleBaseId];
Vector3 battleBasePos = entityPool[battleBase.entityId].pos;

// 获取配送器的位置
Vector3 dispenserPos = entityPool[dispenser.entityId].pos;

// 计算飞行距离和时间
float distance = CalculateSphericalDistance(dispenserPos, battleBasePos, planet.realRadius);
float maxt = distance / courierSpeed;

// 调用游戏原生的派遣方法（这会从 idleCourierDatas 移到 workCourierDatas）
AddPairMethodInfo.Invoke(factory.transport, new object[] 
{ 
    dispenser.id,      // demandId（派出方）
    0,                 // demandIndex
    virtualDispenserId,// supplyId（目标：虚拟配送器）
    gridIdx,           // supplyIndex
    dispenser.filter,  // itemId
    5,                 // itemCount（每次取5个）
    inc                // inc
});

// 此时游戏已经创建了一个 courier，endId = virtualDispenserId
```

---

### 阶段4：无人机返回

无人机装载物品后，`direction = -1f`，开始返回配送器。游戏原生逻辑会处理：
- 无人机飞回配送器
- 到达配送器后卸货
- 然后根据需求继续配送给机甲或其他目标

---

## 潜在问题点

### 问题1：配送器没有设置需求模式和过滤器
**症状**：没有配对，没有派遣
**解决**：用户必须手动设置配送器为"需求"模式，并设置过滤器

### 问题2：InternalTick Prefix 没有执行
**症状**：没有任何诊断日志
**可能原因**：
- Patch 没有应用成功
- 配送器从未 tick（不太可能）
- DLL 版本不对

### 问题3：检查配对时使用了错误的数组长度
**已修复**：从 `pairs.Length` 改为 `playerPairCount`

### 问题4：虚拟配送器的数组字段未初始化
**已修复**：初始化 `workCourierDatas`、`orders`、`pairs` 为空数组

### 问题5：时序问题
**已修复**：在 RefreshDispenserTraffic Postfix 中主动调用 CreateVirtualDispensers

---

## 当前状态

✅ 虚拟配送器创建成功（日志显示：为战场分析基站[1]创建虚拟配送器[27]）
✅ 配对成功（日志显示：添加了4个配对）
❌ 没有派遣无人机（没有看到任何 InternalTick 的日志）

---

## 下一步诊断

1. **确认 DLL 已更新并重新加载**
2. **确认配送器设置**：
   - 模式：需求（Demand）
   - 过滤器：设置为战场基站有的物品（如铁矿1102）
3. **查看新的诊断日志**：
   - "配送器[X] 状态"
   - "检测到虚拟配送器配对"
   - "准备派出无人机"
