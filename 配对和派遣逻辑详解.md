# 配对和派遣逻辑详解

## 🎯 回答用户的两个关键问题

### 问题1：确认无人机和需求
- ✅ **需求方配送器有10个无人机**
- ✅ **配送器设置为需求模式，需要燃料棒**
- ✅ **战场基站有50个燃料棒**

### 问题2：`__instance` 是哪个配送器？

**答案**：`__instance` 是**正在执行 `InternalTick` 的配送器**

游戏会对**所有配送器**（包括虚拟和真实的）都调用 `InternalTick`：
```csharp
[HarmonyPrefix]
static void Prefix(DispenserComponent __instance, ...)
{
    // __instance 是当前正在 Tick 的配送器
    // 每帧游戏会遍历所有配送器，依次调用 InternalTick
}
```

**重要**：
- 当 `__instance.id = 1`（需求方配送器）时，它的 `playerPairCount > 0`
- 当 `__instance.id = 2`（虚拟配送器）时，它的 `playerPairCount = 0`

---

## 🔗 配对的数据结构

### SupplyDemandPair 结构

```csharp
struct SupplyDemandPair
{
    public int supplyId;    // 供应方配送器ID
    public int supplyIdx;   // 供应方的格子索引
    public int demandId;    // 需求方配送器ID
    public int demandIdx;   // 需求方的格子索引
}
```

### 配对是如何建立的

在 `RefreshDispenserTraffic` 中：
```csharp
// 找到需求配送器
DispenserComponent demandDispenser = dispenserPool[dispenserId];  // ID=1，箱子上的配送器

// 获取虚拟配送器ID
int virtualDispenserId = VirtualDispenserManager.GetVirtualDispenserId(battleBaseId);  // ID=2

// 调用需求方配送器的 AddPair 方法
demandDispenser.AddPair(
    supplyId: virtualDispenserId,   // 2 (虚拟配送器，代表战场基站)
    supplyIdx: gridIdx,              // 战场基站的格子索引
    demandId: dispenserId,           // 1 (需求方配送器自己)
    demandIdx: 0                     // 需求方的槽位
);
```

**关键**：配对是添加到**需求方配送器**的 `pairs` 数组中！

---

## 📊 playerPairCount 的含义

### 定义

`playerPairCount` = 该配送器的**配送器到配送器**配对数量

与之对比：
- `pairCount` = 总配对数量（包括配送器到配送器、配送器到存储）
- `playerPairCount` ≤ `pairCount`

### 在游戏代码中

```csharp
// DispenserComponent.AddPair
public void AddPair(int supplyId, int supplyIdx, int demandId, int demandIdx)
{
    // 添加配对到 pairs 数组
    this.pairs[this.pairCount] = new SupplyDemandPair
    {
        supplyId = supplyId,
        supplyIdx = supplyIdx,
        demandId = demandId,
        demandIdx = demandIdx
    };
    
    // 增加玩家配对计数
    this.playerPairCount++;  // ← 关键！
    this.pairCount++;
}
```

**注意**：这个方法是在**需求方配送器**上调用的！

---

## 🔍 配对存储在哪里？

### 示例场景

```
虚拟配送器[2] (代表战场基站)
  ├─ playerPairCount = 0           ← 没有配对
  └─ pairs = []                    ← 空数组

需求配送器[1] (箱子上的配送器)
  ├─ playerPairCount = 1           ← 有1个配对！
  └─ pairs[0] = {
      supplyId: 2,                 ← 虚拟配送器ID
      supplyIdx: 0,                ← 战场基站格子索引
      demandId: 1,                 ← 自己的ID
      demandIdx: 0                 ← 自己的槽位
    }
```

---

## 🚀 派遣逻辑详解

### 我们的代码逻辑

```csharp
[HarmonyPrefix]
static void Prefix(DispenserComponent __instance, ...)
{
    // __instance 每次可能是不同的配送器
    
    // 当 __instance 是虚拟配送器[2]时：
    // - __instance.playerPairCount = 0  ← 不满足条件
    // - 不会派遣 ✅
    
    // 当 __instance 是需求配送器[1]时：
    // - __instance.playerPairCount = 1  ← 满足条件！
    // - __instance.idleCourierCount = 10  ← 有无人机！
    // - 检查 pairs[0].supplyId = 2 是否是虚拟配送器 ← 是！
    // - 派遣无人机 ✅
    
    if (__instance.idleCourierCount > 0 && __instance.playerPairCount > 0)
    {
        // 遍历这个配送器的所有配对
        for (int i = 0; i < __instance.playerPairCount; i++)
        {
            var pair = __instance.pairs[i];
            
            // 检查供应方是否是虚拟配送器
            if (VirtualDispenserManager.IsVirtualDispenser(pair.supplyId))
            {
                // 找到了！派出无人机去虚拟配送器（战场基站）
                DispatchOneCourierToBattleBase(__instance, ...);
                break;
            }
        }
    }
}
```

---

## 🎯 为什么逻辑是正确的

### 配对的视角

```
配对关系：
虚拟配送器[2] (供应) ←→ 需求配送器[1] (需求)

配对数据存储位置：
✅ 存储在需求配送器[1]的 pairs 数组中
❌ 不存储在虚拟配送器[2]中

游戏的 InternalTick 调用：
1. InternalTick(__instance = 虚拟配送器[2])
   - playerPairCount = 0
   - 不派遣（正确！虚拟配送器不应该派遣）

2. InternalTick(__instance = 需求配送器[1])
   - playerPairCount = 1
   - idleCourierCount = 10
   - pairs[0].supplyId = 2 (虚拟配送器)
   - ✅ 应该派遣！
```

---

## 🔍 当前问题：为什么没有派遣？

### 可能的原因

根据逻辑，当 `InternalTick(__instance = 需求配送器[1])` 时，应该满足所有条件：

1. ✅ `__instance.idleCourierCount = 10` (有无人机)
2. ✅ `__instance.playerPairCount = 1` (有配对)
3. ✅ `pairs[0].supplyId = 2` (虚拟配送器)

**但是没有派遣！**

### 诊断假设

#### 假设1：频率控制太严格
```csharp
if (_dispenserCounters[dispenserId] >= DISPATCH_INTERVAL)  // 60帧
{
    // 派遣逻辑
}
```
- ⚠️ 可能：计数器还没达到60帧
- ✅ 解决：新日志会在前20次检查时输出，无论频率

#### 假设2：InternalTick 没有被调用
```csharp
[HarmonyPrefix]
static void Prefix(DispenserComponent __instance, ...)
```
- ⚠️ 可能：Patch 没有正确应用
- ✅ 解决：新日志会输出 Patch 状态

#### 假设3：配对数据不在 pairs 数组中
```csharp
for (int i = 0; i < __instance.playerPairCount; i++)
{
    var pair = __instance.pairs[i];  // ← 这里可能出问题
}
```
- ⚠️ 可能：配对没有正确添加到需求配送器的 pairs 数组
- ✅ 解决：新日志会输出每个 pair 的详细信息

#### 假设4：游戏原生逻辑干扰
```csharp
[HarmonyPrefix]  // ← 我们的 Patch 在游戏原生逻辑之前执行
static void Prefix(...)
```
- ⚠️ 可能：游戏原生 InternalTick 在我们之后执行，修改了状态
- ✅ 解决：使用 Prefix 应该不会被干扰

---

## 🚀 新的诊断日志

### 会输出的信息

```
[战场分析基站配送支持] 🔍 派遣检查 #1: dispenser[1] idle=10, work=0, pairCount=1
[战场分析基站配送支持]   检查 pair[0]: supplyId=2, isVirtual=true
[战场分析基站配送支持] ✅ 发现虚拟配送器配对! dispenser[1] pair[0]: supplyId=2
[战场分析基站配送支持] 🚀 准备派出无人机! dispenser[1] virtualPair[0] idleCouriers=10
```

**或者（如果不满足条件）：**
```
[战场分析基站配送支持] ⚠️ 不满足派遣条件: idle=0, pairs=true, pairCount=1
```

### 关键观察点

1. **是否看到 "派遣检查" 日志？**
   - 是 → InternalTick Patch 工作正常
   - 否 → Patch 没有应用

2. **idle 是否 > 0？**
   - 是 → 配送器有无人机
   - 否 → 需要添加无人机

3. **pairCount 是否 > 0？**
   - 是 → 配对存在
   - 否 → 配对没有添加

4. **是否看到 "检查 pair[0]"？**
   - 是 → pairs 数组有数据
   - 否 → pairs 数组为空或 playerPairCount 不正确

5. **isVirtual 是否为 true？**
   - 是 → 虚拟配送器识别正确
   - 否 → supplyId 不正确

6. **是否看到 "准备派出无人机"？**
   - 是 → 所有条件满足
   - 否 → 某个条件不满足

---

## 📝 总结

### 配对和派遣的完整流程

```
1. 战场基站有物品（燃料棒 x50）
   ↓
2. RefreshDispenserTraffic 被调用
   ↓
3. 检测到需求配送器[1]需要燃料棒
   ↓
4. 创建配对：虚拟配送器[2] → 需求配送器[1]
   ↓
5. 调用 需求配送器[1].AddPair(supplyId=2, ..., demandId=1, ...)
   ↓
6. 配对存储在 需求配送器[1].pairs[0]
   ↓
7. 需求配送器[1].playerPairCount = 1
   ↓
8. 游戏调用 InternalTick(需求配送器[1])
   ↓
9. 我们的 Patch 检测到：
   - idleCourierCount = 10 ✅
   - playerPairCount = 1 ✅
   - pairs[0].supplyId = 2 (虚拟配送器) ✅
   ↓
10. 派出无人机！🚀
```

### 关键点

- ✅ **配对存储在需求方配送器中**
- ✅ **我们检查的是需求方配送器的 InternalTick**
- ✅ **虚拟配送器不派遣无人机（playerPairCount=0）**
- ✅ **需求方配送器派遣无人机（有配对+有无人机）**

### 下一步

**请重启游戏并观察新的诊断日志**，它会告诉我们：
1. InternalTick 是否被调用
2. 配送器的状态（idle, work, pairCount）
3. 配对数据的详细信息
4. 为什么不派遣（如果不满足条件）

日志会在前20次检查时详细输出，之后只在关键时刻输出，避免刷屏。🎯
