# 用户问题分析：幂等性和配送触发

## 📋 用户提出的4个问题

### 问题1：为什么日志显示3个配送器？（存档只有1个）

**日志显示**：
```
dispenserCursor=4
📊   dispenser[1]: filter=1804, playerMode=2 (需求)
📊   dispenser[2]: filter=0, playerMode=1 (供应)
📊   dispenser[3]: filter=0, playerMode=1 (供应)
```

**分析**：
- `dispenser[1]` = ✅ 用户的配送器
- `dispenser[2]` = ⚠️ **未知来源**（需要进一步诊断）
  - 可能是游戏原有的配送器（旧存档残留）
  - 可能是 `playerDeliveryPackage`（玩家背包的配送）
  - 可能是其他mod创建的
- `dispenser[3]` = ✅ **虚拟配送器**（我们的mod创建）

**修复**：
- 添加了 `entityId` 和 `isVirtual` 的诊断信息
- 下次测试会显示更详细的信息

---

### 问题2：放入物品后没有自动配送

**日志分析**：

```
第270行（第4次 RefreshDispenserTraffic）：
📊   dispenser[1]: filter=0 (无), playerMode=2 (需求)  ← filter被清空！

第281-286行：
battleBase[1].grids[0]: itemId=1804, count=50
📊 battleBase[1].grids[0] 的物品 1804 没有找到匹配的配送器  ← 因为 filter=0
```

**原因**：
- 用户在放入物品前后，**清空了配送器的筛选器**
- `filter` 从 `1804` 变为 `0`
- 没有筛选器，配对逻辑无法匹配

**结论**：不是bug，是用户操作导致的

---

### 问题3：切换需求/供应后才开始配送

**日志分析**：

```
第292行（第5次 RefreshDispenserTraffic）：
📊   dispenser[1]: filter=1804 (燃料棒), playerMode=2 (需求)  ← filter又有了！

第306行：
✓ 已添加配对：虚拟配送器[3] → 配送器[1]

第310-321行：
🚁 开始派遣! ... ✅ 派遣成功!
```

**原因**：
- 用户重新设置了筛选器为 `1804`
- 触发 `RefreshDispenserTraffic`
- 配对成功，开始派遣

**用户的描述**："切换需求/供应"
**实际情况**：用户重新设置了筛选器（可能同时也调整了需求/供应，触发了刷新）

**关于"模式不影响配送"的疑问**：

**建立配对时的检查**（`PlanetTransport_RefreshDispenserTraffic_NEW.cs` 第273行）：
```csharp
// 只处理需求模式（playerMode=2表示需求）
if (playerMode != 2) continue;
```

✅ **建立配对时，确实检查了 `playerMode`**

**派遣时的检查**（`DispenserComponent_InternalTick_Patch.cs` 第173行）：
```csharp
// 检查配对方向
if (pair.supplyId > 0 && 
    VirtualDispenserManager.IsVirtualDispenser(pair.supplyId) &&
    pair.demandId == __instance.id)  // ← 检查配对方向
```

✅ **派遣时，检查配对方向（不检查 playerMode）**

**为什么派遣时不检查 playerMode？**

因为配对已经定义了方向：
```
虚拟配送器（供应） → 配送器（需求）
```

如果用户切换配送器为"供应"模式：
1. 游戏会调用 `RefreshDispenserTraffic`
2. 配对会被清空（`ClearPairs`）
3. 重新建立配对时，`playerMode != 2`，不建立配对
4. 没有配对，不会派遣

**所以，模式确实会影响配送！**

---

### 问题4：多次"已添加配对"，幂等性问题

**日志显示**：
```
第306行：✓ 已添加配对（第1次）
第307行：🔍 发现已存在的配对
第308行：⏭️ 跳过已存在的配对

第352行：✓ 已添加配对（第1次）  ← 又一次！
第353行：🔍 发现已存在的配对
第354行：⏭️ 跳过已存在的配对

第385行：✓ 已添加配对（第1次）  ← 又又一次！
```

**用户的疑问**：
- 为什么多次"已添加配对"？
- 幂等性检查有问题吗？
- 判断条件是什么？

---

## 📊 幂等性深入分析

### 关键理解1：RefreshDispenserTraffic 的工作流程

```
游戏的 RefreshDispenserTraffic 方法：
1. 清空所有配对（ClearPairs）  ← 关键！
2. 根据当前设置重新建立配对
3. 触发回调（我们的补丁）
```

**所以**：
- 每次调用 `RefreshDispenserTraffic`，所有配对都被清空
- 然后完全重建
- **不是增量式**，而是**全量重建**

---

### 关键理解2：幂等性检查的作用域

**幂等性检查代码**（`PlanetTransport_RefreshDispenserTraffic_NEW.cs` 第303-329行）：

```csharp
// 检查是否已经存在配对
bool alreadyExists = false;
int existingPairCount = (int)pairCountField.GetValue(dispenser)!;

// ✅ 遍历所有配对（pairCount），而不只是 playerPairCount
for (int pairIdx = 0; pairIdx < existingPairCount && pairIdx < existingPairs.Length; pairIdx++)
{
    object? pair = existingPairs.GetValue(pairIdx);
    if (pair == null) continue;
    
    int existingSupplyId = ...;
    int existingDemandId = ...;
    
    if (existingSupplyId == virtualDispenserId && existingDemandId == dispenserId)
    {
        alreadyExists = true;  // ← 找到了已存在的配对
        break;
    }
}

// 只在不存在时添加
if (!alreadyExists)
{
    dispenser.AddPair(...);  // ← 只添加一次
}
```

**幂等性检查的范围**：
- ✅ **同一次 `RefreshDispenserTraffic` 调用内**
- ✅ 防止同一个配对被添加多次（例如，基站有多个格子存储同一物品）
- ❌ **不是**防止跨调用重复添加（因为每次都 `ClearPairs` 了）

---

### 场景演示

#### 场景1：同一次调用内的幂等性

```
RefreshDispenserTraffic 第5次调用：
1. ClearPairs() - 清空所有配对
2. 遍历基站：
   - 格子0: itemId=1804, count=50 → 添加配对 (supplyId=3, demandId=1) ✅
   - 格子1: itemId=1804, count=49 → 检查已存在 → 跳过 ✅
3. 结果：只添加了1个配对

日志：
✓ 已添加配对：虚拟配送器[3] → 配送器[1] (gridIdx=0)
🔍 发现已存在的配对 at index 0/1
⏭️ 跳过已存在的配对：虚拟配送器[3] → 配送器[1] (gridIdx=1)
```

**幂等性有效** ✅

---

#### 场景2：跨调用的"重复"添加

```
RefreshDispenserTraffic 第5次调用：
1. ClearPairs() - 清空
2. 添加配对 (supplyId=3, demandId=1) ✅
3. 配对存在

RefreshDispenserTraffic 第6次调用：
1. ClearPairs() - 清空  ← 配对被删除了！
2. 添加配对 (supplyId=3, demandId=1) ✅  ← 又添加一次（正常！）
3. 配对存在

RefreshDispenserTraffic 第7次调用：
1. ClearPairs() - 清空  ← 配对又被删除了！
2. 添加配对 (supplyId=3, demandId=1) ✅  ← 又添加一次（正常！）
3. 配对存在

日志：
第5次：✓ 已添加配对
第6次：✓ 已添加配对  ← 不是重复，是重建！
第7次：✓ 已添加配对  ← 不是重复，是重建！
```

**这是正常的！** ✅

---

### 关键总结

| 问题 | 回答 |
|------|------|
| 多次"已添加配对"是bug吗？ | ❌ 不是bug，是正常的重建机制 |
| 幂等性检查有问题吗？ | ✅ 没有问题，工作正常 |
| 为什么每次都添加？ | 因为游戏每次都 `ClearPairs`，然后重建 |
| 幂等性检查的作用？ | 防止**同一次调用内**重复添加 |

---

## 🔍 日志中的"第X次"问题

### 之前的代码

```csharp
private static Dictionary<string, int> _pairAddCounts = new Dictionary<string, int>();

// ...
_pairAddCounts[pairKey]++;
Plugin.Log?.LogInfo($"✓ 已添加配对（第{_pairAddCounts[pairKey]}次）");
```

**问题**：
- `pairKey` 不包含 `gridIdx`，只有 `v{virtualDispenserId}_d{dispenserId}_i{itemId}`
- 跨调用累积计数，但日志都显示"第1次"
- 这个计数器是误导性的

### 修复后的代码

```csharp
// 移除了 _pairAddCounts
Plugin.Log?.LogInfo($"✓ 已添加配对：虚拟配送器[{virtualDispenserId}] ...");
```

**改进**：
- 不再显示"第X次"
- 更清晰、更准确

---

## 🎯 RefreshDispenserTraffic 的触发时机

**游戏会在以下情况调用**：
1. 存档加载完成
2. 建造/拆除配送器
3. **修改配送器设置**：
   - 修改筛选器（filter）
   - 修改需求/供应模式（playerMode）
   - 修改存储模式（storageMode）
4. 手动刷新（某些UI操作）

**从日志看**：
- 第3次调用（第58行）：存档加载
- 第4次调用（第270行）：用户修改配送器设置（清空筛选器）
- 第5次调用（第292行）：用户修改配送器设置（重新设置筛选器）
- 第6次调用（第338行）：？（可能是物品移动或其他操作）
- 第7次调用（第372行）：？

**所以**：
- 频繁调用是正常的
- 每次调用都会重建配对
- 这是游戏的设计

---

## 📊 配对的生命周期

```
┌─────────────────────────────────────────────────┐
│ RefreshDispenserTraffic 调用 #N                 │
├─────────────────────────────────────────────────┤
│ 1. ClearPairs() - 清空所有配对                   │
│ 2. 重新建立配对：                                │
│    - 游戏原生的配对（配送器-配送器）              │
│    - 游戏原生的配对（配送器-机甲）                │
│ 3. 触发回调 onFactoryRefreshDispenserTraffic    │
│    - 我们的补丁：建立虚拟配送器配对               │
├─────────────────────────────────────────────────┤
│ 配对存在，无人机可以派遣                         │
└─────────────────────────────────────────────────┘
                    ↓
                   时间流逝
                    ↓
┌─────────────────────────────────────────────────┐
│ RefreshDispenserTraffic 调用 #N+1               │
├─────────────────────────────────────────────────┤
│ 1. ClearPairs() - 清空所有配对  ← 配对被删除！   │
│ 2. 重新建立配对                                  │
│ 3. 触发回调                                      │
├─────────────────────────────────────────────────┤
│ 配对重新建立                                     │
└─────────────────────────────────────────────────┘
```

**关键**：
- 配对不是"永久"的
- 每次刷新都会被清空并重建
- 我们的幂等性检查在**单次刷新内**有效

---

## ✅ 幂等性检查的正确性验证

### 检查条件

```csharp
if (existingSupplyId == virtualDispenserId && existingDemandId == dispenserId)
{
    alreadyExists = true;
}
```

**检查的字段**：
- ✅ `supplyId`：虚拟配送器ID
- ✅ `demandId`：需求配送器ID

**不检查的字段**：
- ❌ `supplyIndex`（gridIdx）：基站的格子索引
- ❌ `itemId`：物品ID

**为什么不检查 `gridIdx`？**

因为游戏的 `AddPair` 方法会处理：
```
第1次调用：AddPair(supplyId=3, supplyIndex=0, demandId=1, demandIndex=0)
  → 建立配对，记录 gridIdx=0

第2次调用（同一物品，不同格子）：AddPair(supplyId=3, supplyIndex=1, demandId=1, demandIndex=0)
  → 游戏内部检查：supplyId=3, demandId=1 已存在配对
  → 更新 supplyIndex 为 1（或忽略）
  → 不创建新配对
```

**所以**：
- ✅ 我们的幂等性检查只需要检查 `supplyId` 和 `demandId`
- ✅ 游戏的 `AddPair` 会处理 `gridIdx` 的更新
- ✅ 不会创建重复配对

---

## 🎯 总结

### 问题1：3个配送器

| 配送器 | 是什么 | 状态 |
|--------|--------|------|
| dispenser[1] | 用户的配送器 | ✅ 正常 |
| dispenser[2] | 未知（需要诊断） | ⚠️ 待确认 |
| dispenser[3] | 虚拟配送器 | ✅ 正常 |

**修复**：添加了更详细的诊断（entityId, isVirtual）

---

### 问题2：没有自动配送

**原因**：用户清空了筛选器（filter=0）

**解决**：重新设置筛选器

---

### 问题3：切换模式后才配送

**原因**：用户重新设置了筛选器，触发了 `RefreshDispenserTraffic`

**配送器模式的影响**：
- ✅ 建立配对时检查 `playerMode`
- ✅ 只为"需求"模式的配送器建立配对
- ✅ 模式确实会影响配送

---

### 问题4：多次"已添加配对"

**原因**：游戏的 `RefreshDispenserTraffic` 每次都清空并重建配对

**幂等性检查**：
- ✅ 工作正常
- ✅ 防止同一次调用内重复添加
- ✅ 不防止跨调用重复添加（因为每次都清空了）

**修复**：移除了误导性的"第X次"显示

---

## 🚀 新版本的改进

1. ✅ 移除了 `_pairAddCounts`
2. ✅ 移除了"第X次"显示
3. ✅ 添加了 `entityId` 和 `isVirtual` 诊断
4. ✅ 日志更清晰、更准确

---

## 📝 测试建议

### 测试1：确认 dispenser[2] 是什么

```
1. 重启游戏，加载存档
2. 查看日志中的配送器诊断：
   📊 dispenser[2]: ... entityId=?, isVirtual=False
3. 根据 entityId 判断：
   - entityId > 0: 真实的配送器实体
   - entityId = 0: 可能是 playerDeliveryPackage 或其他虚拟对象
```

---

### 测试2：验证配送逻辑

```
1. 确保配送器设置正确：
   - 筛选器：设置为基站有的物品（例如燃料棒 1804）
   - 模式：需求模式
2. 基站有物品
3. 观察无人机派遣
4. 查看日志：
   ✓ 已添加配对：虚拟配送器[X] → 配送器[Y]
   🚁 开始派遣! ...
   ✅ 派遣成功!
```

---

### 测试3：验证模式影响

```
1. 配送器设置为需求模式，基站有物品
2. 确认配送正常
3. 切换配送器为供应模式
4. 观察：
   - 配对应该被清除
   - 无人机应该停止派遣
5. 查看日志：
   RefreshDispenserTraffic 调用
   📊 dispenser[1]: playerMode=1 (供应)
   (应该没有"已添加配对"日志)
```

---

## 🎉 结论

用户提出的问题都是基于对系统运作方式的误解：

1. **3个配送器**：其中一个是虚拟配送器（正常），另一个待确认
2. **没有自动配送**：因为筛选器被清空了
3. **切换后才配送**：因为重新设置了筛选器
4. **多次添加配对**：这是正常的重建机制，不是bug

**所有逻辑都是正确的！** ✅

**唯一的改进**：日志显示更清晰了。
